<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Business Card - Interactive</title>

  <!-- A-Frame and AR.js Libraries -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.7/aframe/build/aframe-ar.min.js"></script>

  <!-- Gesture Components -->
  <script src="https://cdn.jsdelivr.net/gh/fcor/arjs-gestures@master/dist/gesture-detector.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/fcor/arjs-gestures@master/dist/gesture-handler.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    .arjs-loader { /* ... same styles ... */ }
    .arjs-loader div { /* ... same styles ... */ }
    .reminder-message { /* ... same styles ... */ }
    @keyframes flash { /* ... same styles ... */ }
  </style>

  <!-- NEW: Custom Drag-Move Component -->
  <script>
    AFRAME.registerComponent('drag-move', {
      schema: {
        speed: { type: 'number', default: 0.004 } // Sensitivity of dragging
      },

      init: function () {
        this.isDragging = false;
        this.previousPosition = { x: 0, y: 0 };
        this.marker = this.el.closest('a-marker'); // Find the parent marker
        this.canDrag = false; // Only drag when marker is visible

        // Bind event handlers
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onMarkerFound = this.onMarkerFound.bind(this);
        this.onMarkerLost = this.onMarkerLost.bind(this);

        // Listen for marker visibility
        if (this.marker) {
          this.marker.addEventListener('markerFound', this.onMarkerFound);
          this.marker.addEventListener('markerLost', this.onMarkerLost);
        } else {
          console.warn('drag-move component could not find a parent marker.');
          this.canDrag = true; // Allow dragging even without marker context if needed
        }

        // Add listeners to the scene canvas
        this.el.sceneEl.canvas.addEventListener('mousedown', this.onMouseDown);
        this.el.sceneEl.canvas.addEventListener('mousemove', this.onMouseMove);
        this.el.sceneEl.canvas.addEventListener('mouseup', this.onMouseUp);
        this.el.sceneEl.canvas.addEventListener('touchstart', this.onTouchStart);
        this.el.sceneEl.canvas.addEventListener('touchmove', this.onTouchMove);
        this.el.sceneEl.canvas.addEventListener('touchend', this.onTouchEnd);
      },

      remove: function () {
        // Remove listeners
        this.el.sceneEl.canvas.removeEventListener('mousedown', this.onMouseDown);
        this.el.sceneEl.canvas.removeEventListener('mousemove', this.onMouseMove);
        this.el.sceneEl.canvas.removeEventListener('mouseup', this.onMouseUp);
        this.el.sceneEl.canvas.removeEventListener('touchstart', this.onTouchStart);
        this.el.sceneEl.canvas.removeEventListener('touchmove', this.onTouchMove);
        this.el.sceneEl.canvas.removeEventListener('touchend', this.onTouchEnd);

        if (this.marker) {
          this.marker.removeEventListener('markerFound', this.onMarkerFound);
          this.marker.removeEventListener('markerLost', this.onMarkerLost);
        }
      },

      onMarkerFound: function() {
        this.canDrag = true;
        // console.log("Marker Found - Drag Enabled");
      },

      onMarkerLost: function() {
        this.canDrag = false;
        this.isDragging = false; // Stop dragging if marker is lost
        // console.log("Marker Lost - Drag Disabled");
      },

      // --- Mouse Events ---
      onMouseDown: function (event) {
        if (!this.canDrag || event.button !== 0) return; // Only drag if marker visible and left mouse button
        // Check if the click originated on our entity (or allow dragging anywhere?)
        // For simplicity, let's allow dragging anywhere on the canvas when marker is visible.
        this.isDragging = true;
        this.previousPosition = { x: event.clientX, y: event.clientY };
        // console.log("Mouse Down - Start Drag");
      },

      onMouseMove: function (event) {
        if (!this.isDragging || !this.canDrag) return;

        const deltaX = event.clientX - this.previousPosition.x;
        const deltaY = event.clientY - this.previousPosition.y;

        const currentPosition = this.el.getAttribute('position');

        // Map screen movement (X, Y) to object's local plane (X, Z)
        // Adjust signs and axes based on your desired interaction
        const newPosition = {
          x: currentPosition.x + deltaX * this.data.speed,
          y: currentPosition.y, // Keep Y the same
          z: currentPosition.z + deltaY * this.data.speed // Screen Y maps to Object Z
          // Use -deltaY if you want moving finger up to move object away
        };

        this.el.setAttribute('position', newPosition);
        this.previousPosition = { x: event.clientX, y: event.clientY };
        // console.log("Mouse Move - Dragging");
      },

      onMouseUp: function () {
        if (this.isDragging) {
          // console.log("Mouse Up - End Drag");
        }
        this.isDragging = false;
      },

      // --- Touch Events ---
      onTouchStart: function (event) {
        // Check for single touch and marker visibility
        if (!this.canDrag || event.touches.length !== 1) {
            // If more than one touch, let gesture-handler potentially take over
            this.isDragging = false; // Ensure drag stops if a second finger is added
            return;
        }
        this.isDragging = true;
        this.previousPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        // console.log("Touch Start - Start Drag");
      },

      onTouchMove: function (event) {
        // Ensure it's still a single touch drag
        if (!this.isDragging || !this.canDrag || event.touches.length !== 1) {
            this.isDragging = false; // Stop dragging if touches change
            return;
        }

        const deltaX = event.touches[0].clientX - this.previousPosition.x;
        const deltaY = event.touches[0].clientY - this.previousPosition.y;

        const currentPosition = this.el.getAttribute('position');
        const newPosition = {
          x: currentPosition.x + deltaX * this.data.speed,
          y: currentPosition.y,
          z: currentPosition.z + deltaY * this.data.speed
        };

        this.el.setAttribute('position', newPosition);
        this.previousPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        // console.log("Touch Move - Dragging");

        // Prevent default scroll/zoom behavior during drag
        event.preventDefault();
      },

      onTouchEnd: function (event) {
         // Check if the drag was ongoing and is now ending (0 touches left)
         if (this.isDragging && event.touches.length === 0) {
            // console.log("Touch End - End Drag");
            this.isDragging = false;
         }
         // If touches remain (e.g., went from 2 fingers to 1), gesture-handler might still be active,
         // but our single-finger drag state should be false.
      }
    });
  </script>

</head>

<body>
  <!-- Loading Indicator -->
  <div class="arjs-loader">
    <div>Loading, please wait...</div>
  </div>

  <!-- Reminder Message -->
  <div class="reminder-message">
    Please scan the same QR code to view AR content
  </div>

  <a-scene
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono;"
    renderer="logarithmicDepthBuffer: true; precision: medium;"
    loading-screen="enabled: false"
    gesture-detector <!-- Detects gestures for gesture-handler -->
  >
    <!-- Pattern Marker -->
    <a-marker
      type="pattern"
      url="assets/pattern-qrcode_samip-ac.github.io.patt"
      id="ar-marker"
      raycaster="objects: .clickable" <!-- Keep for potential clicks -->
      emitevents="true"
      cursor="fuse: false; rayOrigin: mouse;" <!-- Keep for potential clicks -->
    >
      <a-entity
        gltf-model="url(assets/SamIp_business_card.glb)"
        scale="1.4 1.4 1.4"
        position="0 0.1 0"
        rotation="90 90 90"
        class="clickable"
        gesture-handler="minScale: 0.5; maxScale: 3; rotationFactor: 5" <!-- Handles scale and rotate -->
        drag-move="speed: 0.005" <!-- ADDED: Handles drag-to-move -->
        id="ar-object"
      ></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // Variables to track marker visibility (Existing script)
    let markerVisible = false;
    const reminder = document.querySelector('.reminder-message');
    const markerEl = document.querySelector('#ar-marker'); // Renamed to avoid conflict
    const sceneEl = document.querySelector('a-scene'); // Get scene reference

    // Show reminder message immediately when page loads
    window.addEventListener('load', function() {
      reminder.style.display = 'block';
    });

    // Hide loader when scene is ready
    sceneEl.addEventListener('loaded', function() {
      document.querySelector('.arjs-loader').style.display = 'none';

      // Set up marker visibility detection (already handled by drag-move component now,
      // but keep this for the reminder message)
      if (markerEl) {
          markerEl.addEventListener('markerFound', function() {
            markerVisible = true;
            reminder.style.display = 'none';
          });

          markerEl.addEventListener('markerLost', function() {
            markerVisible = false;
            reminder.style.display = 'block';
          });
      } else {
          console.error("Marker element #ar-marker not found for reminder logic.");
      }

    });
  </script>
</body>
</html>


<!-- assets/rx-0_full_armor_unicorn_gundam.glb:
scale="0.3 0.3 0.3"
position="0 0.1 0"
rotation="0 180 0" -->
